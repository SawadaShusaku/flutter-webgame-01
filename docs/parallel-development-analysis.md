# 並列開発の効率性分析

## 日付
2025-11-09

## 質問
Phase A（初期配置フェーズ）の実装を複数ペインで並列実行すべきか？

---

## 前回の並列開発（失敗例）

### 実施内容
- **4ペイン並列開発**: Phase 3-7を一気に実装
- **分割方法**: ディレクトリ単位（services/, ui/screens/, ui/widgets/, integration/）
- **期間**: 1日
- **結果**: 29個以上のビルドエラー

### 失敗の原因
1. **情報共有の不足**: 各ペインがAPIの変更を知らなかった
2. **依存関係の複雑化**: モデル変更が全ペインに影響
3. **統合時の衝突**: 同時マージで大量エラー

### 修正にかかった時間
- エラー修正: 2-3時間
- ドキュメント作成: 1時間
- **合計**: 並列開発で得た時間を全て失った

---

## 今回の状況（Phase A: 初期配置フェーズ）

### 実装する機能
1. **SetupService** - 初期配置ロジック（新規サービス）
2. **タップ検出** - Vertex/EdgeWidgetの改修
3. **ハイライト表示** - Vertex/EdgeWidgetのUI改善
4. **SetupScreen** - 初期配置画面の実装
5. **GameController統合** - タップイベントの接続

### 依存関係の分析

```
SetupService (新規)
    ↓ 使用される
GameController (既存、改修)
    ↓ 使用される
SetupScreen (既存、改修)
    ↓ 表示する
GameBoardWidget (既存、改修)
    ↓ 含む
VertexWidget (既存、改修)
EdgeWidget (既存、改修)
```

**問題点**: 全てが相互依存している

---

## 並列開発の可否判定

### ✅ 並列開発が成功する条件
1. **独立した機能**: 各ペインが異なる機能を実装
2. **依存関係が少ない**: ペイン間で呼び出しがほぼない
3. **インターフェースが確定**: 使用するAPIが変更されない
4. **統合が簡単**: 最後にマージするだけで動く

### ❌ Phase Aの状況
1. **独立していない**: 全てが相互に依存
2. **依存関係が複雑**:
   - SetupService → GameController → SetupScreen → GameBoardWidget → VertexWidget
3. **インターフェースが未確定**:
   - SetupServiceは新規なので、どんなAPIにするか実装しながら決まる
   - GameControllerにどんなメソッドを追加するかも実装次第
4. **統合が困難**:
   - 各ペインが異なる想定でAPIを実装 → エラー多発の可能性

---

## 並列開発 vs 順次開発の比較

### シナリオ1: 並列開発（4ペイン）

#### 分割案
```
Pane 1: SetupServiceの実装
Pane 2: GameControllerの改修（タップハンドリング）
Pane 3: VertexWidget/EdgeWidgetのタップ検出
Pane 4: SetupScreenのUI実装
```

#### 予想されるタイムライン
- **Day 1**: 並列実装（各2時間） = 2時間
- **Day 2**: 統合作業（エラー修正） = 4-6時間
- **合計**: 6-8時間

#### リスク
- **高リスク**: インターフェースの不一致で大量エラー
- **前回と同じ失敗**: APIが確定していないため、各ペインが異なる想定で実装
- **統合コスト**: エラー修正に時間がかかる

### シナリオ2: 順次開発（1ペイン）

#### 実装順序
```
Step 1: SetupServiceの基本実装（1時間）
Step 2: GameControllerに統合（30分）
Step 3: VertexWidgetのタップ検出（30分）
Step 4: EdgeWidgetのタップ検出（30分）
Step 5: SetupScreenのUI（1時間）
Step 6: 統合テスト（30分）
```

#### 予想されるタイムライン
- **Day 1**: 順次実装 = 4時間
- **統合作業**: ほぼ不要（実装しながら統合済み）
- **合計**: 4時間

#### メリット
- **低リスク**: 各ステップで動作確認しながら進む
- **エラーが少ない**: インターフェースを実装しながら決定
- **デバッグが簡単**: 問題が起きたら直前のステップに戻るだけ

---

## 並列開発が有効なケース（参考）

### 例: Phase B + Phase C の並列実装

仮にPhase Aが完了した後、Phase BとPhase Cを並列実装する場合：

```
Pane 1: Phase B（サイコロ機能）
    - DiceRollerウィジェット改善
    - 資源生産フロー
    - 7の処理

Pane 2: Phase C（建設インタラクション）
    - BuildModeの追加
    - 建設フロー実装
    - ハイライト表示
```

#### なぜ成功する可能性が高いか
1. **独立している**: サイコロと建設は異なる機能
2. **依存関係が少ない**: 両方ともGameControllerを使うが、異なるメソッド
3. **インターフェースが確定**: Phase A完了時点でGameControllerのAPIが確定
4. **統合が簡単**: 両方をマージしても衝突しない

#### 予想タイムライン
- **並列実装**: 2時間（同時進行）
- **統合**: 30分（ほぼエラーなし）
- **合計**: 2.5時間

**順次実装の場合**: 4時間
**並列開発の利益**: 1.5時間の短縮 ✅

---

## 結論と推奨事項

### Phase Aについての結論

**❌ 並列開発は推奨しない**

#### 理由
1. **相互依存が強い**: 全ての要素が密接に関連
2. **APIが未確定**: 実装しながらインターフェースを決める必要がある
3. **統合コストが高い**: 前回と同様のエラーが予想される
4. **時間的メリットが少ない**:
   - 並列: 2時間実装 + 4-6時間修正 = 6-8時間
   - 順次: 4時間実装 + 0時間修正 = 4時間
   - **順次の方が2-4時間速い**

### 推奨アプローチ

#### Phase A: 順次開発
```
1. SetupServiceの実装
2. GameControllerへの統合
3. Widgetのタップ検出
4. SetupScreenのUI
```

**予想時間**: 4時間
**リスク**: 低
**成功率**: 高

#### Phase B + Phase C: 並列開発（Phase A完了後）
Phase Aが完了し、インターフェースが確定した後なら、Phase BとPhase Cは並列実装可能。

**予想時間短縮**: 1.5時間
**リスク**: 中
**成功率**: 中〜高

---

## 並列開発チェックリスト（将来用）

並列開発を検討する際のチェックリスト：

### ✅ 並列開発すべき条件（全て満たす必要あり）
- [ ] 各ペインの機能が独立している
- [ ] 依存関係が片方向か、ほぼない
- [ ] 使用するAPIが既に確定している
- [ ] 各ペインが異なるファイルを編集する
- [ ] 統合時の衝突が予想されない
- [ ] 実装時間が長い（各2時間以上）

### ❌ 順次開発すべき条件（1つでも該当）
- [ ] 相互依存が強い
- [ ] APIが未確定で、実装しながら決める
- [ ] 同じファイルを複数ペインが編集する
- [ ] 実装時間が短い（合計4時間以下）
- [ ] 新規機能で動作が予測しづらい

---

## Phase Aの実装方針

### 採用する方法: **順次開発（1ペイン）**

### タイムライン
```
Hour 1-2: SetupServiceの実装 + GameController統合
Hour 3: Widgetのタップ検出実装
Hour 4: SetupScreenのUI実装
Hour 5: テスト + 修正
```

### 次のアクション
Phase Aを順次開発で実装開始します。

**実装を開始しますか？**
